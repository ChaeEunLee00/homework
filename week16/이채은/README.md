# ▶숙제

### BOJ 15787 기차가 어둠을 헤치고 은하수를
- 구현 + 비트마스킹
  - 비트마스킹: 비트를 활용해 데이터를 효율적으로 저장하고 조작하는 것
    - `&`: AND 연산
    - `|`: OR 연산
    - `^`: XOR 연산
    - `~`: 모든 비트 반전
    - `<<`: 모든 비트 왼쪽 이동
    - `>>`: 모든 비트 오른쪽 이동

### BOJ 2064 IP 주소
- 구현 + 비트마스킹
  - 네트워크 마스크: 모든 ip에 대해 같은 위치의 비트가 같은지 비교 -> 같으면 1, 다르면 그 이후부터는 모두 0
  - 네트워크 주소: 한 ip 주소와 네크워크 마스크의 교집합

### PGS 도둑질
- 다이나믹 프로그래밍 (dp)
- `dp[i]`: i 번째 집까지 터는 경우 훔칠 수 있는 돈의 최댓값
  - i 번째 집을 터는 경우 `money[i] + dp[i-2]`
  - i 번째 집을 털지 않는 경우 `dp[i-1]`
  - 따라서, 점화식은 `dp[i] = Math.max(money[i] + dp[i-2], dp[i-1])`
- 집들이 동그랗게 배치되어 있기 때문에, 첫번째 집을 터는 경우와 털지 않는 경우 총 2가지 경우의 dp 진행 
  - 첫번째 집을 터는 경우 dp 초기화: `dp1[0] = money[0]`, `dp1[1] = dp1[0]`
  - 첫번째 집을 털지 않는 경우 dp 초기화: `dp2[0] = 0`, `dp2[1] = money[1]`
- `dp1[N-2]`, `dp2[N-1]` 중 최댓값이 최종 정답

### PGS 섬 연결하기
- 최소 스패닝 트리 (MST)
  - `크루스칼 알고리즘`: 간선을 중심으로 MST를 구함
    - 그리디: 선택되지 않은 간선 중 최소 가중치를 가진 간선 선택
    - 유니온파인드: 사이클이 생기지 않을 경우(= 서로소 집합일 경우) 해당 간선 추가

### PGS 미로 탈출 명령어
- 깊이 우선 탐색 (dfs)
  - `최단 거리 > k`이거나, `k-최단거리`가 홀수인 경우, `impossible`
  - 사전 순으로 탐색 `d -> l -> r -> u`
    - 시간초과 방지를 위한 가지치기 : 누적 이동 거리 + 남은 최단 거리 > k 이면 도달 불가

### BOJ 1720 타일 코드
- 13주차에 풀었던 문제

### PGS 주사위 고르기
- 조합 + 백트래킹 + 이진탐색
  - A/B가 주사위를 나누는 모든 경우의 수 구함 (조합)
  - 각 조합에서 A의 승리 횟수 계산
    - A 주사위로 가능한 모든 합 목록 / B 주사위로 가능한 모든 합 목록 구함 (백트래킹)
    - 정렬된 B 합에 대해, A의 각 합이 이기는 개수 카운트 (이진탐색)
    - 전부 더해 해당 조합의 승리 수 산출
  - 최댓값이면 정답 갱신

### BOJ 13302 리조트
- 다이나믹 프로그래밍 (dp)
  - `dp[i][j]`: i 번째 날 쿠폰 j장 가지고 있을 때 최소비용
  - 점화식
      - 불가능한 날: `dp[i][j] = Math.min(dp[i][j], dp[i-1][j])`
      - 쿠폰 3장 사용: `dp[i][j-3] = Math.min(dp[i][j-3], dp[i-1][j])`
      - 1일 이용권: `dp[i][j] = Math.min(dp[i][j], dp[i-1][j]+ONE_DAY)`
      - 3일 이용권: `dp[i+k][j+1] = Math.min(dp[i+k][j+1], dp[i-1][j]+THREE_DAY)`, `k = 0~2`
      - 5일 이용권: `dp[i+k][j+2] = Math.min(dp[i+k][j+2], dp[i-1][j]+FIVE_DAY)`, `k = 0~4`