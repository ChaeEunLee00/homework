# ▶숙제

### BOJ 6603 로또
- 백트래킹
  - 6개의 수를 선택하는 모든 경우의 수를 구함

### BOJ 1911 흙길 보수하기
- 그리디
  - 물웅덩이 오름차순
  - 물웅덩이 순회하며 앞에서부터 널빤지 덮기
    - `cursor`: 지금까지 널빤지로 덮은 가장 오른쪽 위치
      - cursor가 물웅덩이의 start보다 크거나 같으면, start를 cursor로 갱신
      - cursor가 물웅덩이의 start보다 작으면, start부터 새로운 널빤지 덮기
    - 현재 물웅덩이에 필요한 널빤지 갯수 계산
      - `필요한 널빤지 갯수` = `(end - start + K - 1) / K`
      - 올림을 나눗셈으로 표현한 식
    - 덮은 구간의 끝(cursor) 갱신
      - `cursor` = `start + 널빤지개수*K`

### BOJ 1774 우주신과의 교감
- 최소 스패닝 트리 (MST)
  - `크루스칼 알고리즘`: 간선을 중심으로 MST를 구함
    - 그리디: 선택되지 않은 간선 중 최소 가중치를 가진 간선 선택
    - 유니온파인드: 사이클이 생기지 않을 경우(= 서로소 집합일 경우) 해당 간선 추가

### BOJ 18809 Gaaaaaaaaaarden
- 백트래킹 
  - 초록,빨강 배양액을 뿌릴 수 있는 모든 경우의 수 탐색
- 너비우선탐색 (bfs)
  - 배양액을 뿌리는 각 경우에 대해 배양 시작

### PGS 완전범죄
- 다이나믹 프로그래밍 (dp)
  - `dp[i][j]` = i번째 물건까지 훔치고 B의 누적 흔적 수가 j일 때, A의 최소 누적 흔적 수
  - 점화식 
    - i번째 물건을 A가 훔쳤을 때 
      - `dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + info[i][0])`
    - i번째 물건을 B가 훔쳤을 때
      - `dp[i][j+info[i][1]] = Math.min(dp[i][j+info[i][1]], dp[i-1][j])`
  - 최종 결과
    -  `dp[마지막 물건][j]` 중 최소값 
    - 최솟값이 n 이상이라면 -1 반환

### PGS 카펫
- 완전탐색
  - 총 격자의 수 `total = brown + yellow`를 구해 `total = w * h` 를 만족하는 `w`,`h` 완전탐색
  - 각 `w`,`h`에 대한 `calBrown`,`calYellow`를 계산하여 실제 `brown`,`yellow`와 같으면 해당 `w`,`h` 반환 
    - `calBrown = (w-1)*2 + (h-1)*2`
    - `calYellow = (w-2) * (h-2)`
      

### 

### 
